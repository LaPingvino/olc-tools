<!doctype html>
<html>
    <head>
        <title>
            whenwhere.uk - Dead simple lightweight communication and
            coordination
        </title>
        <script>
            if (
                window.location.protocol.substring(0, 5) != "https" &&
                (window.location.hostname == "whenwhere.uk" ||
                    window.location.hostname == "www.whenwhere.uk" ||
                    window.location.hostname == "donde.ir" ||
                    window.location.hostname == "www.donde.ir")
            ) {
                window.location.protocol = "https:";
            }
        </script>
        <script src="hivejs.min.js"></script>
        <script src="markdown.min.js"></script>
        <script src="localmessages.js"></script>
        <script src="openlocationcode.min.js"></script>
        <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        />
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <meta name="viewport" content="initial-scale=1" />
        <meta name="theme-color" value="#f8f9fa" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black" />
        <meta name="apple-mobile-web-app-title" content="WhenWhere.uk" />
        <link rel="apple-touch-icon" href="/images/icons/icon-152x152.png" />
        <link rel="manifest" href="manifest.json" />
        <link rel="canonical" href="https://whenwhere.uk" />
        <style>
            @import url("https://fonts.googleapis.com/css?family=Roboto+Slab:400,700&display=swap");

            :root {
                --primary-color: #007bff;
                --secondary-color: #6c757d;
                --light-gray: #f8f9fa;
                --dark-gray: #343a40;
                --border-color: #dee2e6;
                --text-color: #212529;
                --link-color: #007bff;
                --link-hover-color: #0056b3;
            }

            body {
                font-family: "Roboto Slab", serif;
                font-size: 16px;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--light-gray);
                margin: 0;
                padding: 20px;
                display: flex;
                flex-direction: column;
                align-items: center;
                min-height: 100vh;
                box-sizing: border-box;
            }

            .container {
                background-color: white;
                padding: 25px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                width: 100%;
                max-width: 700px;
                margin-bottom: 20px;
            }

            h1 {
                font-size: 2.5em;
                color: var(--primary-color);
                text-align: center;
                margin-top: 0;
                margin-bottom: 20px;
            }

            #nowat,
            #shortcode,
            #accuracy {
                color: var(--secondary-color);
                font-size: 0.9em;
                text-align: center;
                margin-bottom: 10px;
            }

            #code {
                font-size: 2.8em; /* Slightly reduced for better fit */
                font-weight: 700;
                color: var(--primary-color);
                text-align: center;
                margin: 10px 0 5px; /* Adjusted margin */
                padding: 10px;
                background-color: var(--light-gray);
                border-radius: 4px;
                word-break: break-all; /* Ensure long codes don't overflow */
                /* user-select: all; REMOVED to prevent selection issues */
                /* cursor: pointer; REMOVED as it's not directly clickable for action */
            }

            /* #code:hover {
                background-color: #e9ecef; REMOVED as it's not interactive
            } */

            .action-buttons {
                margin-top: 10px;
                margin-bottom: 15px; /* Added margin below buttons */
                display: flex;
                justify-content: center;
                gap: 10px;
            }

            .action-buttons button {
                font-family: "Roboto Slab", serif;
                font-size: 0.9em; /* Adjusted for text + emoji */
                padding: 8px 15px;
                border: 1px solid var(--border-color);
                background-color: white;
                color: var(--primary-color);
                border-radius: 4px;
                cursor: pointer;
                transition:
                    background-color 0.2s ease,
                    border-color 0.2s ease;
                display: inline-flex; /* Align icon and text */
                align-items: center;
                gap: 5px; /* Space between icon and text */
            }

            .action-buttons button:hover {
                background-color: #e9ecef;
                border-color: var(--primary-color);
            }

            .action-buttons button:active {
                background-color: #d3d9df;
            }

            #local {
                font-weight: 700; /* Already bold, but explicit due to parent #code also being 700 */
                color: var(--dark-gray); /* Make it visually distinct */
            }

            #nav {
                text-align: center;
                margin: 20px 0;
                padding: 15px;
                background-color: #f8f9fa;
                border-radius: 6px;
                border: 1px solid var(--border-color);
            }

            #navinput {
                font-family: "Roboto Slab", serif;
                font-size: 1em;
                padding: 10px 15px;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                width: calc(
                    100% - 80px
                ); /* Adjusted width to account for button */
                max-width: 200px; /* Adjusted max width */
                margin: 10px 5px 10px 0;
                display: inline-block;
                box-sizing: border-box;
                vertical-align: middle;
            }

            #navinput:focus {
                outline: none;
                border-color: var(--primary-color);
                box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
            }

            #refresh-nav {
                background: var(--primary-color);
                color: white;
                border: none;
                border-radius: 4px;
                padding: 10px 12px;
                margin: 10px 0;
                cursor: pointer;
                font-size: 1em;
                display: inline-block;
                vertical-align: middle;
                height: 44px; /* Match input height */
                box-sizing: border-box;
            }

            #refresh-nav:hover {
                background: #0056b3;
            }

            #refresh-nav:active {
                transform: translateY(1px);
            }

            #manual-location-section {
                background: #f8f9fa;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                padding: 15px;
                margin: 20px 0;
                display: none;
            }

            #manual-location {
                font-family: "Roboto Slab", serif;
                font-size: 1em;
                padding: 10px 15px;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                width: calc(100% - 80px);
                max-width: 200px;
                margin: 10px 5px 10px 0;
                display: inline-block;
                box-sizing: border-box;
                vertical-align: middle;
            }

            #set-location-btn {
                background: var(--primary-color);
                color: white;
                border: none;
                border-radius: 4px;
                padding: 10px 12px;
                margin: 10px 0;
                cursor: pointer;
                font-size: 1em;
                display: inline-block;
                vertical-align: middle;
                height: 44px;
                box-sizing: border-box;
            }

            #set-location-btn:hover {
                background: #0056b3;
            }

            #enable-manual-location {
                background: #007bff;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 12px;
                margin: 10px 0;
                cursor: pointer;
                font-size: 0.9em;
                display: block;
                transition: background-color 0.2s;
            }

            #enable-manual-location:hover {
                background: #0056b3;
            }

            .location-picker-item {
                transition: background-color 0.2s;
            }

            #cache-status {
                font-size: 0.8em;
                color: #6c757d;
                margin-top: 10px;
            }

            #clear-cache-btn {
                background: #dc3545;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 5px 10px;
                margin: 5px 0 0 10px;
                cursor: pointer;
                font-size: 0.8em;
            }

            #clear-cache-btn:hover {
                background: #c82333;
            }

            #direction-compass {
                position: relative;
                width: 120px;
                height: 120px;
                border: 3px solid var(--primary-color);
                border-radius: 50%;
                margin: 20px auto;
                display: none;
                transition: transform 0.3s ease;
                background: radial-gradient(circle, #ffffff 30%, #f8f9fa 100%);
                box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            }

            #direction-arrow {
                position: absolute;
                top: 10px;
                left: 50%;
                width: 0;
                height: 0;
                border-left: 8px solid transparent;
                border-right: 8px solid transparent;
                border-bottom: 20px solid var(--primary-color);
                transform: translateX(-50%);
                transition: transform 0.3s ease;
                transform-origin: center 35px;
            }

            #compass-labels {
                position: relative;
                width: 100px;
                height: 100px;
            }

            .compass-label {
                position: absolute;
                font-size: 14px;
                font-weight: bold;
                color: var(--primary-color);
                text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
            }

            .compass-label.north {
                top: 2px;
                left: 50%;
                transform: translateX(-50%);
            }

            .compass-label.south {
                bottom: 2px;
                left: 50%;
                transform: translateX(-50%);
            }

            .compass-label.east {
                right: 2px;
                top: 50%;
                transform: translateY(-50%);
            }

            .compass-label.west {
                left: 2px;
                top: 50%;
                transform: translateY(-50%);
            }

            #mini-map {
                width: 400px;
                height: 300px;
                border: 2px solid var(--primary-color);
                border-radius: 8px;
                margin: 20px auto;
                display: none;
            }

            #nav1,
            #nav2 {
                display: block;
                margin-bottom: 5px;
                font-size: 0.95em;
            }
            #nav2 {
                color: var(--secondary-color);
                font-size: 0.85em;
            }

            hr {
                border: 0;
                height: 1px;
                background-color: var(--border-color);
                margin: 30px 0;
            }

            #more,
            #source {
                font-size: 0.9em;
                color: var(--secondary-color);
                line-height: 1.7;
            }

            #more b {
                color: var(--dark-gray);
                display: block;
                margin-bottom: 8px;
                font-size: 1.1em;
            }

            #more a,
            #source a {
                color: var(--link-color);
                text-decoration: none;
                font-weight: 700;
            }

            #more a:hover,
            #source a:hover {
                color: var(--link-hover-color);
                text-decoration: underline;
            }

            #messages {
                margin-top: 20px;
                padding: 15px;
                background-color: #f8f9fa;
                border: 1px solid var(--border-color);
                border-radius: 6px;
                min-height: 100px;
            }

            .message {
                margin: 10px 0;
                padding: 15px;
                border: 1px solid var(--border-color);
                border-left: 4px solid var(--primary-color);
                background-color: white;
                border-radius: 4px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            }

            #source {
                text-align: center;
                margin-top: 30px;
                font-size: 0.8em;
            }

            /* Utility class for small text */
            .text-muted {
                color: var(--secondary-color);
            }

            /* Responsive adjustments */
            @media (max-width: 600px) {
                body {
                    padding: 10px;
                }
                .container {
                    padding: 15px;
                }
                #code {
                    font-size: 2.2em;
                }
                h1 {
                    font-size: 2em;
                }
                #navinput {
                    width: calc(
                        100% - 60px
                    ); /* Full width minus button on small screens */
                    max-width: none;
                }
                #refresh-nav {
                    margin-left: 5px;
                }
                #manual-location {
                    width: calc(100% - 60px);
                    max-width: none;
                }
                .action-buttons button {
                    font-size: 0.8em;
                    padding: 6px 10px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>WhenWhere.uk</h1>
            <div id="nowat">You are at:</div>
            <div id="code" title="Waiting for location...">
                <span id="region">0000</span><wbr /><span id="local"
                    >0000+00</span
                >
            </div>
            <div class="action-buttons">
                <button id="copyCodeButton" title="Copy Code">📋 Copy</button>
                <button id="shareCodeButton" title="Share Link & Code">
                    🔗 Share
                </button>
            </div>
            <div id="accuracy" class="text-muted">
                Please be patient. If this stays here too long, something is
                wrong.
            </div>
            <div id="shortcode" class="text-muted">
                If someone is already close to you, the darker last part of the
                code is enough.
            </div>

            <div id="nav">
                <span id="nav1">Go to:</span>
                <div style="text-align: center">
                    <input
                        id="navinput"
                        placeholder="Enter OLC, short code + location, or place name (e.g., 9G8F+6W London)"
                        type="text"
                    />
                    <button
                        id="refresh-nav"
                        onclick="refreshNavigationEnhanced()"
                        title="Recalculate distance"
                    >
                        🔄
                    </button>
                </div>
                <span id="nav2">(enter OLC)</span>

                <!-- Direction Compass -->
                <div id="direction-compass">
                    <div id="compass-labels">
                        <div class="compass-label north">N</div>
                        <div class="compass-label south">S</div>
                        <div class="compass-label east">E</div>
                        <div class="compass-label west">W</div>
                    </div>
                    <div id="direction-arrow"></div>
                </div>

                <!-- Mini Map -->
                <div id="mini-map"></div>
            </div>

            <button
                id="enable-manual-location"
                onclick="toggleManualLocation()"
            >
                📍 Enter location manually
            </button>

            <div id="manual-location-section">
                <div style="margin-bottom: 10px">
                    <strong>Manual Location Entry</strong><br />
                    <small
                        >Enter your location manually or when GPS is
                        unavailable. Multiple results will show a picker.</small
                    >
                </div>
                <div style="text-align: center">
                    <input
                        id="manual-location"
                        placeholder="Enter your current location (e.g., London, UK)"
                        type="text"
                        onkeypress="if(event.key==='Enter') setManualLocation()"
                    />
                    <button id="set-location-btn" onclick="setManualLocation()">
                        Set
                    </button>
                </div>
                <div
                    id="manual-location-status"
                    style="
                        margin-top: 10px;
                        font-size: 0.9em;
                        color: var(--secondary-color);
                    "
                ></div>
                <div id="cache-status">
                    Nominatim results are cached for 24 hours to improve
                    performance.
                    <button
                        id="clear-cache-btn"
                        onclick="clearNominatimCache()"
                    >
                        Clear Cache
                    </button>
                </div>
            </div>

            <hr />

            <div id="more">
                <b>Do more with this code:</b>
                <p>
                    <a
                        id="navapp"
                        href="https://www.google.com/maps/@?api=1&map_action=map"
                        >Navigate with a map app</a
                    >, look at the
                    <a id="map" href="https://plus.codes/map/"
                        >full map around the OLC</a
                    >, do a
                    <a
                        id="refhref"
                        href="https://nominatim.openstreetmap.org/reverse.php?format=html&zoom=12"
                        >reverse lookup</a
                    >
                    to get possible reference points to get people to the right
                    region first. You can also enter place names or short codes
                    with location references (like "9G8F+6W London" or just
                    "Central Park") which will be geocoded using OpenStreetMap.
                </p>
                <p>
                    Want more info?
                    <a href="https://plus.codes"
                        >Get the full story about Plus-codes</a
                    >. There is also a
                    <a href="precise.html"
                        >more precise version for e.g. slum navigation</a
                    >.
                </p>
            </div>

            <hr />

            <div id="messages">
                Here you will see messages of people around you...
            </div>
        </div>

        <div id="source">
            Although the code is ugly, it's open source. Find it on
            <a href="https://github.com/lapingvino/olc-tools/"
                >lapingvino/olc-tools</a
            >
            on Github.
        </div>

        <script>
            document.getElementById("navinput").value =
                localStorage.getItem(location.pathname) ||
                location.hash.substring(1);
            let nav2default = document.getElementById("nav2").innerHTML;
            let dot = "."; // This is used for a subtle animation/indicator
            let isCodeInteractionPaused = false; // Flag to pause OLC updates during copy/share

            function dist(lat1, lon1, lat2, lon2) {
                var R = 6371; // Radius of the earth in km
                var dLat = deg2rad(lat2 - lat1); // deg2rad below
                var dLon = deg2rad(lon2 - lon1);
                var a =
                    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(deg2rad(lat1)) *
                        Math.cos(deg2rad(lat2)) *
                        Math.sin(dLon / 2) *
                        Math.sin(dLon / 2);
                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                var d = R * c; // Distance in km
                return Math.floor(d * 1000); //return round distance in meters
            }

            function dirfunc(lat1, long1, lat2, long2) {
                t = 0.000125;
                n = lat1 - lat2;
                e = long1 - long2;
                if (Math.abs(e) > 90) {
                    e = -e;
                } // Correct for longitude wrapping
                ns = n > 0 ? "south" : "north";
                es = e > 0 ? "west" : "east";
                r = "";
                if (Math.abs(n) > t) {
                    r +=
                        Math.floor(Math.abs(n) * 100000) +
                        " \u{1F6B6} " +
                        ns +
                        " ";
                }
                if (Math.abs(e) > t) {
                    r +=
                        Math.floor(Math.abs(e) * 100000) +
                        " \u{1F6B6} " +
                        es +
                        " ";
                }
                if (r == "") {
                    r = "You've arrived! \u{1F3C1}";
                }
                return r;
            }

            // Cache for Nominatim results
            const nominatimCache = new Map();
            const CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

            // Rate limiting for Nominatim API
            let lastNominatimRequest = 0;
            const NOMINATIM_RATE_LIMIT = 1100; // 1.1 seconds between requests (Nominatim allows 1 req/sec)
            const pendingRequests = new Map(); // Track pending requests to avoid duplicates

            // Destination caching and failed lookup tracking
            const destinationCache = new Map();
            const failedLookups = new Map();
            const FAILED_LOOKUP_RETRY_DELAY = 30000; // Wait 30 seconds before retrying failed lookups
            let lastKnownGoodDestination = null;
            let lastKnownGoodInput = "";

            function getCacheKey(query) {
                return `nominatim_${query.toLowerCase().trim()}`;
            }

            function getCachedResult(query) {
                try {
                    const cacheKey = getCacheKey(query);
                    const cached = localStorage.getItem(cacheKey);
                    if (cached) {
                        const { data, timestamp } = JSON.parse(cached);
                        if (Date.now() - timestamp < CACHE_EXPIRY) {
                            console.log(
                                "Using cached Nominatim result for:",
                                query,
                            );
                            return data;
                        } else {
                            localStorage.removeItem(cacheKey);
                        }
                    }
                } catch (e) {
                    console.warn("Error reading cache:", e);
                }
                return null;
            }

            function setCachedResult(query, data) {
                try {
                    const cacheKey = getCacheKey(query);
                    localStorage.setItem(
                        cacheKey,
                        JSON.stringify({
                            data,
                            timestamp: Date.now(),
                        }),
                    );
                } catch (e) {
                    console.warn("Error setting cache:", e);
                }
            }

            // Geocode using Nominatim API with caching, rate limiting and multiple results
            async function geocodeWithNominatim(query, showPicker = false) {
                try {
                    // Check cache first
                    const cachedResult = getCachedResult(query);
                    if (cachedResult && !showPicker) {
                        return cachedResult;
                    }

                    const cacheKey = getCacheKey(query);

                    // Check if we already have a pending request for this query
                    if (pendingRequests.has(cacheKey)) {
                        console.log("Waiting for existing request for:", query);
                        return await pendingRequests.get(cacheKey);
                    }

                    // Rate limiting check
                    const now = Date.now();
                    const timeSinceLastRequest = now - lastNominatimRequest;

                    if (timeSinceLastRequest < NOMINATIM_RATE_LIMIT) {
                        const waitTime = NOMINATIM_RATE_LIMIT - timeSinceLastRequest;
                        console.log(`Rate limiting: waiting ${waitTime}ms before Nominatim request`);
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                    }

                    console.log("Sending Nominatim request for:", query);
                    lastNominatimRequest = Date.now();
                    const limit = showPicker ? 5 : 1;
                    // Create and store the promise for this request
                    const requestPromise = (async () => {
                        const response = await fetch(
                            `https://nominatim.openstreetmap.org/search?format=json&limit=${limit}&q=${encodeURIComponent(query)}`,
                            {
                                headers: {
                                    "User-Agent":
                                        "whenwhere.uk/1.0 (https://whenwhere.uk; contact via GitHub)",
                                },
                            },
                        );

                        if (!response.ok) {
                            throw new Error(`Nominatim HTTP error: ${response.status}`);
                        }

                        return await response.json();
                    })();

                    pendingRequests.set(cacheKey, requestPromise);

                    let data;
                    try {
                        data = await requestPromise;
                    } finally {
                        // Clean up pending request
                        pendingRequests.delete(cacheKey);
                    }
                    console.log("Nominatim response:", data);

                    if (data && data.length > 0) {
                        if (showPicker && data.length > 1) {
                            // Show location picker
                            return await showLocationPicker(data);
                        }

                        const result = data[0];
                        const lat = parseFloat(result.lat);
                        const lon = parseFloat(result.lon);
                        console.log(
                            `Nominatim found: ${result.display_name} at ${lat}, ${lon}`,
                        );

                        // Return in OpenLocationCode decode format
                        const locationResult = {
                            latitudeCenter: lat,
                            longitudeCenter: lon,
                            codeLength: 10, // Default length for geocoded results
                            latitudeLo: lat - 0.000125, // Approximate bounds
                            latitudeHi: lat + 0.000125,
                            longitudeLo: lon - 0.000125,
                            longitudeHi: lon + 0.000125,
                            display_name: result.display_name,
                        };

                        // Cache the result
                        setCachedResult(query, locationResult);
                        return locationResult;
                    }
                    console.log("No results found in Nominatim response");
                    return null;
                } catch (e) {
                    console.warn("Nominatim geocoding error:", e.message);

                    // Clean up pending request on error
                    const cacheKey = getCacheKey(query);
                    pendingRequests.delete(cacheKey);

                    // If it's a rate limit error, wait longer before next request
                    if (e.message.includes("429") || e.message.includes("rate limit")) {
                        console.log("Rate limit detected, extending delay");
                        lastNominatimRequest = Date.now() + 5000; // Wait extra 5 seconds
                    }

                    return null;
                }
            }

            // Check if we should skip a lookup due to recent failure
            function shouldSkipLookup(query) {
                const normalizedQuery = query.toLowerCase().trim();
                const failTime = failedLookups.get(normalizedQuery);
                if (failTime && (Date.now() - failTime) < FAILED_LOOKUP_RETRY_DELAY) {
                    return true;
                }
                return false;
            }

            // Record a failed lookup
            function recordFailedLookup(query) {
                const normalizedQuery = query.toLowerCase().trim();
                failedLookups.set(normalizedQuery, Date.now());
            }

            // Clear failed lookup record (when lookup succeeds)
            function clearFailedLookup(query) {
                const normalizedQuery = query.toLowerCase().trim();
                failedLookups.delete(normalizedQuery);
            }

            // Show location picker when multiple results are found
            async function showLocationPicker(locations) {
                return new Promise((resolve) => {
                    const modal = document.createElement("div");
                    modal.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.5);
                        z-index: 1000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;

                    const dialog = document.createElement("div");
                    dialog.style.cssText = `
                        background: white;
                        border-radius: 8px;
                        padding: 20px;
                        max-width: 500px;
                        max-height: 80vh;
                        overflow-y: auto;
                        margin: 20px;
                    `;

                    const title = document.createElement("h3");
                    title.textContent = "Select Location";
                    title.style.marginTop = "0";
                    dialog.appendChild(title);

                    const list = document.createElement("div");
                    locations.forEach((location, index) => {
                        const item = document.createElement("div");
                        item.style.cssText = `
                            padding: 10px;
                            border: 1px solid #ddd;
                            margin: 5px 0;
                            border-radius: 4px;
                            cursor: pointer;
                            background: #f9f9f9;
                        `;
                        item.textContent = location.display_name;

                        item.onclick = () => {
                            const lat = parseFloat(location.lat);
                            const lon = parseFloat(location.lon);
                            const result = {
                                latitudeCenter: lat,
                                longitudeCenter: lon,
                                codeLength: 10,
                                latitudeLo: lat - 0.000125,
                                latitudeHi: lat + 0.000125,
                                longitudeLo: lon - 0.000125,
                                longitudeHi: lon + 0.000125,
                                display_name: location.display_name,
                            };
                            document.body.removeChild(modal);
                            resolve(result);
                        };

                        item.onmouseover = () => {
                            item.style.background = "#e9ecef";
                        };
                        item.onmouseout = () => {
                            item.style.background = "#f9f9f9";
                        };

                        list.appendChild(item);
                    });
                    dialog.appendChild(list);

                    const cancelBtn = document.createElement("button");
                    cancelBtn.textContent = "Cancel";
                    cancelBtn.style.cssText = `
                        margin-top: 15px;
                        padding: 8px 16px;
                        background: #6c757d;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                    `;
                    cancelBtn.onclick = () => {
                        document.body.removeChild(modal);
                        resolve(null);
                    };
                    dialog.appendChild(cancelBtn);

                    modal.appendChild(dialog);
                    document.body.appendChild(modal);
                });
            }

            // Clear Nominatim cache
            function clearNominatimCache() {
                try {
                    const keys = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith("nominatim_")) {
                            keys.push(key);
                        }
                    }
                    keys.forEach((key) => localStorage.removeItem(key));

                    // Also clear destination cache and failed lookups
                    destinationCache.clear();
                    failedLookups.clear();

                    const status = document.getElementById("cache-status");
                    status.innerHTML = `Cleared ${keys.length} cached location${keys.length !== 1 ? "s" : ""} and reset destination cache. Nominatim results are cached for 24 hours to improve performance. <button id="clear-cache-btn" onclick="clearNominatimCache()">Clear Cache</button>`;

                    setTimeout(() => {
                        status.innerHTML =
                            'Nominatim results are cached for 24 hours to improve performance. <button id="clear-cache-btn" onclick="clearNominatimCache()">Clear Cache</button>';
                    }, 3000);
                } catch (e) {
                    console.warn("Error clearing cache:", e);
                }
            }

            function resolve(code, lat, lon) {
                // Ensure code is a string and not empty.
                if (typeof code !== "string" || code.trim() === "") {
                    return null;
                }
                const upperCode = code.trim().toUpperCase();

                try {
                    let recoveredFullCode = OpenLocationCode.recoverNearest(
                        upperCode,
                        lat,
                        lon,
                    );
                    return OpenLocationCode.decode(recoveredFullCode);
                } catch (e) {
                    console.warn(
                        "OLC resolve/decode error for input '" +
                            upperCode +
                            "': " +
                            e.message,
                    );
                    return null;
                }
            }

            // Parse input to separate potential short code from location reference
            function parseShortCodeInput(input) {
                const trimmed = input.trim().toUpperCase();

                // Look for patterns like "9G8F+6W London" or "London 9G8F+6W"
                const codePattern = /([A-Z0-9]{4,8}\+[A-Z0-9]{2,3})/;
                const match = trimmed.match(codePattern);

                if (match) {
                    const code = match[1];
                    const location = trimmed.replace(codePattern, "").trim();
                    return { code, location: location || null };
                }

                // Check if it looks like a short code without location reference
                if (trimmed.includes("+") && trimmed.length < 8) {
                    return { code: trimmed, location: null };
                }

                return null;
            }

            // Enhanced resolve function with Nominatim-based reference location lookup
            async function resolveWithGeocoding(code, lat, lon) {
                console.log(
                    `Starting resolution for: "${code}" at position ${lat}, ${lon}`,
                );

                // Check destination cache first
                const destCacheKey = `${code}_${lat.toFixed(4)}_${lon.toFixed(4)}`;
                const cachedDestination = destinationCache.get(destCacheKey);
                if (cachedDestination && (Date.now() - cachedDestination.timestamp) < CACHE_EXPIRY) {
                    console.log("Using cached destination for:", code);
                    return cachedDestination.destination;
                }

                // Check if we should skip due to recent failure
                if (shouldSkipLookup(code)) {
                    console.log("Skipping lookup due to recent failure:", code);
                    return lastKnownGoodDestination;
                }

                // First try the standard OLC resolve (includes short codes with current position)
                const olcResult = resolve(code, lat, lon);
                if (olcResult) {
                    console.log("Successfully resolved as OLC:", olcResult);
                    clearFailedLookup(code);
                    // Cache the successful result
                    destinationCache.set(destCacheKey, {
                        destination: olcResult,
                        timestamp: Date.now()
                    });
                    return olcResult;
                }

                // Parse the input to see if it contains a short code with location reference
                const parsed = parseShortCodeInput(code);

                if (parsed && parsed.code) {
                    console.log(
                        "Detected short code:",
                        parsed.code,
                        "with location:",
                        parsed.location,
                    );

                    if (parsed.location) {
                        // Use Nominatim to find reference location for short code resolution
                        console.log(
                            "Looking up reference location:",
                            parsed.location,
                        );
                        const referenceResult = await geocodeWithNominatim(
                            parsed.location,
                        );

                        if (referenceResult) {
                            console.log(
                                "Found reference location, re-attempting short code resolution",
                            );
                            const shortCodeResult = resolve(
                                parsed.code,
                                referenceResult.latitudeCenter,
                                referenceResult.longitudeCenter,
                            );
                            if (shortCodeResult) {
                                console.log(
                                    "Successfully resolved short code with reference location",
                                );
                                clearFailedLookup(code);
                                // Cache the successful result
                                destinationCache.set(destCacheKey, {
                                    destination: shortCodeResult,
                                    timestamp: Date.now()
                                });
                                return shortCodeResult;
                            }
                        }
                    }

                    console.log(
                        "Short code resolution with reference location failed",
                    );
                    return null;
                }

                // If not a short code, try Nominatim geocoding for place names/addresses
                console.log(
                    "Attempting Nominatim geocoding for place name:",
                    code,
                );
                const nominatimResult = await geocodeWithNominatim(code);
                if (nominatimResult) {
                    console.log(
                        "Successfully geocoded place name:",
                        nominatimResult,
                    );
                    clearFailedLookup(code);
                    // Cache the successful result
                    destinationCache.set(destCacheKey, {
                        destination: nominatimResult,
                        timestamp: Date.now()
                    });
                    return nominatimResult;
                } else {
                    console.log("Place name geocoding also failed");
                    recordFailedLookup(code);
                    return null;
                }
            }

            function deg2rad(deg) {
                return deg * (Math.PI / 180);
            }

            // Store the last known location for manual refresh
            let lastKnownLocation = null;

            // Manual refresh function for navigation
            async function refreshNavigation() {
                console.log("Manual navigation refresh triggered");
                document.getElementById("nav2").innerHTML = "Refreshing...";

                let coords = null;

                // Try to use manual location first
                if (isManualLocationMode && manualLocationCoords) {
                    coords = manualLocationCoords;
                    console.log("Using manual location for refresh");
                }
                // Try to use last known GPS location
                else if (lastKnownLocation) {
                    coords = lastKnownLocation;
                    console.log("Using cached GPS location for refresh");
                }
                // Try to get fresh GPS location as last resort
                else {
                    try {
                        const position = await new Promise(
                            (resolve, reject) => {
                                navigator.geolocation.getCurrentPosition(
                                    resolve,
                                    reject,
                                    {
                                        enableHighAccuracy: true,
                                        timeout: 5000,
                                        maximumAge: 30000,
                                    },
                                );
                            },
                        );
                        coords = position.coords;
                        lastKnownLocation = coords;
                        console.log("Got fresh GPS location for refresh");
                    } catch (error) {
                        console.error("All location methods failed:", error);
                        document.getElementById("nav2").innerHTML =
                            "(No location available - try manual location mode)";
                        return;
                    }
                }

                // Now proceed with navigation calculation
                let navInputValue = document
                    .getElementById("navinput")
                    .value.trim();
                let navInputUpper = navInputValue.toUpperCase();

                if (navInputValue) {
                    // Only resolve if input has changed and we're not already resolving
                    if (navInputValue !== lastNavInput && !isResolvingDestination) {
                        isResolvingDestination = true;
                        lastNavInput = navInputValue;

                        try {
                            let destination = await resolveWithGeocoding(
                                navInputUpper,
                                coords.latitude,
                                coords.longitude,
                            );
                            if (destination) {
                                lastKnownDestination = destination;
                            }
                            // If resolution failed, keep using lastKnownDestination if it exists
                        } catch (e) {
                            console.warn("Error resolving destination:", e);
                            // Keep using lastKnownDestination if it exists
                        } finally {
                            isResolvingDestination = false;
                        }
                    }

                    // Use last known destination if available
                    if (lastKnownDestination) {
                        let distance = dist(
                            coords.latitude,
                            coords.longitude,
                            lastKnownDestination.latitudeCenter,
                            lastKnownDestination.longitudeCenter,
                        );
                        let direction = dirfunc(
                            coords.latitude,
                            coords.longitude,
                            lastKnownDestination.latitudeCenter,
                            lastKnownDestination.longitudeCenter,
                        );
                        document.getElementById("nav2").innerHTML =
                            `Target is ~${distance}m away (${direction})`;

                        // Update compass and map for manual refresh
                        updateCompass(
                            coords.latitude,
                            coords.longitude,
                            lastKnownDestination.latitudeCenter,
                            lastKnownDestination.longitudeCenter,
                        );
                        updateMiniMap(
                            coords.latitude,
                            coords.longitude,
                            lastKnownDestination.latitudeCenter,
                            lastKnownDestination.longitudeCenter,
                        );
                    } else if (!isResolvingDestination) {
                        if (!lastKnownGoodDestination) {
                            document.getElementById("nav2").innerHTML =
                                "(Location not found - invalid OLC or unknown place)";
                            document.getElementById(
                                "direction-compass",
                            ).style.display = "none";
                            // Show current location only when no destination
                            showCurrentLocationOnMap(
                                coords.latitude,
                                coords.longitude,
                            );
                        } else {
                            // Use last known good destination
                            let distance = dist(
                                coords.latitude,
                                coords.longitude,
                                lastKnownGoodDestination.latitudeCenter,
                                lastKnownGoodDestination.longitudeCenter,
                            );
                            let direction = dirfunc(
                                coords.latitude,
                                coords.longitude,
                                lastKnownGoodDestination.latitudeCenter,
                                lastKnownGoodDestination.longitudeCenter,
                            );
                            document.getElementById("nav2").innerHTML =
                                `Target is ~${distance}m away (${direction}) [cached]`;

                            updateCompass(
                                coords.latitude,
                                coords.longitude,
                                lastKnownGoodDestination.latitudeCenter,
                                lastKnownGoodDestination.longitudeCenter,
                            );
                            updateMiniMap(
                                coords.latitude,
                                coords.longitude,
                                lastKnownGoodDestination.latitudeCenter,
                                lastKnownGoodDestination.longitudeCenter,
                            );
                        }
                    }
                } else {
                    document.getElementById("nav2").innerHTML = nav2default;
                    document.getElementById("direction-compass").style.display =
                        "none";
                    // Show current location only when no navigation target
                    if (coords) {
                        showCurrentLocationOnMap(
                            coords.latitude,
                            coords.longitude,
                        );
                    } else {
                        document.getElementById("mini-map").style.display =
                            "none";
                    }
                }
            }

            // Enhanced refresh that works with manual location too
            async function refreshNavigationEnhanced() {
                // The refreshNavigation function now handles all cases automatically
                await refreshNavigation();
            }

            // Manual location variables
            let manualLocationCoords = null;
            let isManualLocationMode = false;

            // Toggle manual location input
            function toggleManualLocation() {
                const section = document.getElementById(
                    "manual-location-section",
                );
                if (section.style.display === "none") {
                    section.style.display = "block";
                } else {
                    section.style.display = "none";
                }
            }

            // Set manual location using Nominatim
            async function setManualLocation() {
                const input = document.getElementById("manual-location");
                const status = document.getElementById(
                    "manual-location-status",
                );
                const locationText = input.value.trim();

                if (!locationText) {
                    status.innerHTML = "Please enter a location";
                    return;
                }

                status.innerHTML = "Looking up location...";

                try {
                    const result = await geocodeWithNominatim(
                        locationText,
                        true,
                    );
                    if (result) {
                        manualLocationCoords = {
                            latitude: result.latitudeCenter,
                            longitude: result.longitudeCenter,
                            accuracy: 1000, // Assume 1km accuracy for manual locations
                        };
                        isManualLocationMode = true;

                        const displayName =
                            result.display_name ||
                            `${result.latitudeCenter.toFixed(6)}, ${result.longitudeCenter.toFixed(6)}`;
                        status.innerHTML = `Location set to: ${displayName}`;

                        // Update the display with manual location
                        updateDisplayWithManualLocation();

                        // Hide the manual location section
                        document.getElementById(
                            "manual-location-section",
                        ).style.display = "none";
                    } else {
                        status.innerHTML =
                            "Location not found. Try a different search term.";
                    }
                } catch (error) {
                    console.error("Error setting manual location:", error);
                    status.innerHTML = "Error looking up location.";
                }
            }

            // Update display with manual location
            async function updateDisplayWithManualLocation() {
                if (!manualLocationCoords) return;

                const coords = manualLocationCoords;

                // Update the OLC display
                let length = 8; // Medium precision for manual locations
                currentOlc = OpenLocationCode.encode(
                    coords.latitude,
                    coords.longitude,
                    length,
                );

                document.getElementById("code").title = currentOlc;
                document.getElementById("region").innerHTML =
                    currentOlc.substring(0, 4);
                document.getElementById("local").innerHTML =
                    currentOlc.substring(4);
                document.getElementById("accuracy").innerHTML =
                    `Manual location (±${Math.floor(coords.accuracy)}m)`;

                // Update navigation if there's a destination
                let navInputValue = document
                    .getElementById("navinput")
                    .value.trim();
                if (navInputValue) {
                    // Only resolve if input has changed and we're not already resolving
                    if (navInputValue !== lastNavInput && !isResolvingDestination) {
                        isResolvingDestination = true;
                        lastNavInput = navInputValue;

                        try {
                            let destination = await resolveWithGeocoding(
                                navInputValue.toUpperCase(),
                                coords.latitude,
                                coords.longitude,
                            );
                            if (destination) {
                                lastKnownDestination = destination;
                            }
                        } catch (e) {
                            console.warn("Error resolving"Error updating navigation with manual location:",
                            e,
                        );
                    }
                }
            }

            // Device orientation variables
            let deviceHeading = 0; // Current device compass heading
            let isOrientationSupported = false;
            let orientationPermissionRequested = false;
            let lastOrientationUpdate = 0;
            let orientationTimeout = null;

            // Navigation state management
            let lastKnownDestination = null;
            let lastNavInput = "";
            let isResolvingDestination = false;

            // Calculate bearing between two points
            function calculateBearing(lat1, lon1, lat2, lon2) {
                const dLon = deg2rad(lon2 - lon1);
                const y = Math.sin(dLon) * Math.cos(deg2rad(lat2));
                const x =
                    Math.cos(deg2rad(lat1)) * Math.sin(deg2rad(lat2)) -
                    Math.sin(deg2rad(lat1)) *
                        Math.cos(deg2rad(lat2)) *
                        Math.cos(dLon);
                return (Math.atan2(y, x) * 180) / Math.PI;
            }

            // Request device orientation permission (needed for iOS 13+)
            async function requestOrientationPermission() {
                if (
                    typeof DeviceOrientationEvent !== "undefined" &&
                    typeof DeviceOrientationEvent.requestPermission ===
                        "function" &&
                    !orientationPermissionRequested
                ) {
                    orientationPermissionRequested = true;
                    try {
                        const permission =
                            await DeviceOrientationEvent.requestPermission();
                        if (permission === "granted") {
                            enableDeviceOrientation();
                        } else {
                            console.log("Device orientation permission denied");
                        }
                    } catch (error) {
                        console.log(
                            "Error requesting device orientation permission:",
                            error,
                        );
                    }
                } else if (typeof DeviceOrientationEvent !== "undefined") {
                    // Android or older iOS - no permission needed
                    enableDeviceOrientation();
                }
            }

            // Enable device orientation listening
            function enableDeviceOrientation() {
                if (typeof DeviceOrientationEvent !== "undefined") {
                    window.addEventListener(
                        "deviceorientationabsolute",
                        handleOrientation,
                        true,
                    );
                    window.addEventListener(
                        "deviceorientation",
                        handleOrientation,
                        true,
                    );
                    isOrientationSupported = true;
                    console.log("Device orientation enabled");
                }
            }

            // Handle device orientation changes
            function handleOrientation(event) {
                // Use webkitCompassHeading for iOS, alpha for Android
                let heading = event.webkitCompassHeading || event.alpha;

                if (heading !== null && heading !== undefined) {
                    lastOrientationUpdate = Date.now();

                    // webkitCompassHeading is already correct (0 = North)
                    // alpha needs to be converted (0 = North, but clockwise)
                    if (event.webkitCompassHeading !== undefined) {
                        deviceHeading = heading;
                    } else {
                        // For Android, alpha is 0 at North but increases counter-clockwise
                        // We need clockwise from North
                        deviceHeading = 360 - heading;
                    }

                    // Update compass if it's visible
                    updateCompassWithOrientation();

                    // Reset timeout
                    if (orientationTimeout) {
                        clearTimeout(orientationTimeout);
                    }
                    orientationTimeout = setTimeout(
                        checkOrientationStatus,
                        5000,
                    );
                }
            }

            // Update compass rotation with device orientation
            function updateCompassWithOrientation() {
                const compass = document.getElementById("direction-compass");
                if (compass && compass.style.display === "block") {
                    // Rotate the entire compass based on device heading
                    compass.style.transform = `rotate(${-deviceHeading}deg)`;
                }
            }

            // Check if orientation is still working
            function checkOrientationStatus() {
                const timeSinceLastUpdate = Date.now() - lastOrientationUpdate;
                if (timeSinceLastUpdate > 10000 && isOrientationSupported) {
                    // Orientation hasn't updated in 10 seconds, might have stopped
                    console.warn("Device orientation appears to have stopped");
                }
            }

            // Initialize device orientation on page load
            document.addEventListener("DOMContentLoaded", function () {
                // Auto-enable for Android and older iOS
                if (
                    typeof DeviceOrientationEvent !== "undefined" &&
                    typeof DeviceOrientationEvent.requestPermission !==
                        "function"
                ) {
                    enableDeviceOrientation();
                }
            });

            // Update compass arrow direction
            function updateCompass(fromLat, fromLon, toLat, toLon) {
                const bearing = calculateBearing(
                    fromLat,
                    fromLon,
                    toLat,
                    toLon,
                );
                const arrow = document.getElementById("direction-arrow");
                const compass = document.getElementById("direction-compass");

                compass.style.display = "block";

                // Store bearing for orientation updates
                compass.setAttribute("data-bearing", bearing);

                // Set arrow direction (bearing is relative to North)
                arrow.style.transform = `translateX(-50%) rotate(${bearing}deg)`;

                // Apply device orientation if supported
                if (isOrientationSupported) {
                    compass.style.transform = `rotate(${-deviceHeading}deg)`;
                } else {
                    // Show a button to enable orientation on iOS
                    if (
                        !orientationPermissionRequested &&
                        typeof DeviceOrientationEvent !== "undefined" &&
                        typeof DeviceOrientationEvent.requestPermission ===
                            "function"
                    ) {
                        showOrientationButton();
                    }
                }

                // Update mini map
                updateMiniMap(fromLat, fromLon, toLat, toLon);
            }

            // Show button to enable device orientation
            function showOrientationButton() {
                const existingBtn =
                    document.getElementById("enable-compass-btn");
                if (!existingBtn) {
                    const compassDiv =
                        document.getElementById("direction-compass");
                    const btn = document.createElement("button");
                    btn.id = "enable-compass-btn";
                    btn.innerHTML = "🧭 Enable Compass Rotation";
                    btn.style.cssText = `
                        position: absolute;
                        bottom: -40px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: #28a745;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        padding: 5px 10px;
                        font-size: 0.8em;
                        cursor: pointer;
                    `;
                    btn.onclick = () => {
                        requestOrientationPermission();
                        // Remove button after click
                        setTimeout(() => {
                            if (btn.parentNode) {
                                btn.parentNode.removeChild(btn);
                            }
                        }, 1000);
                    };
                    compassDiv.appendChild(btn);
                }
            }

            let miniMap = null;
            let currentLocationMarker = null;
            let destinationMarker = null;

            // Initialize or update mini map - now shows only current location at street level
            function updateMiniMap(fromLat, fromLon, toLat, toLon) {
                const mapContainer = document.getElementById("mini-map");
                mapContainer.style.display = "block";

                if (!miniMap) {
                    // Initialize map
                    miniMap = L.map("mini-map", {
                        zoomControl: false,
                        scrollWheelZoom: false,
                        doubleClickZoom: false,
                        dragging: false,
                    });

                    // Add tile layer
                    L.tileLayer(
                        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                        {
                            attribution: "© OpenStreetMap contributors",
                        },
                    ).addTo(miniMap);
                }

                // Clear all existing layers (markers, lines, etc.)
                miniMap.eachLayer(function (layer) {
                    if (
                        layer instanceof L.Marker ||
                        layer instanceof L.Polyline
                    ) {
                        miniMap.removeLayer(layer);
                    }
                });

                // Clear references to old markers
                currentLocationMarker = null;
                destinationMarker = null;

                // Add only the current location marker
                currentLocationMarker = L.marker([fromLat, fromLon])
                    .addTo(miniMap)
                    .bindPopup("You are here");

                // Focus on current location at street level (zoom 16-17 is good for navigation)
                miniMap.setView([fromLat, fromLon], 16);
            }

            // Show current location only on the map
            function showCurrentLocationOnMap(lat, lon) {
                const mapContainer = document.getElementById("mini-map");
                mapContainer.style.display = "block";

                if (!miniMap) {
                    // Initialize map
                    miniMap = L.map("mini-map", {
                        zoomControl: false,
                        scrollWheelZoom: false,
                        doubleClickZoom: false,
                        dragging: false,
                    });

                    // Add tile layer
                    L.tileLayer(
                        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                        {
                            attribution: "© OpenStreetMap contributors",
                        },
                    ).addTo(miniMap);
                }

                // Clear all existing layers
                miniMap.eachLayer(function (layer) {
                    if (
                        layer instanceof L.Marker ||
                        layer instanceof L.Polyline
                    ) {
                        miniMap.removeLayer(layer);
                    }
                });

                // Clear references to old markers
                currentLocationMarker = null;
                destinationMarker = null;

                // Add current location marker
                currentLocationMarker = L.marker([lat, lon])
                    .addTo(miniMap)
                    .bindPopup("You are here");

                // Focus on current location at street level
                miniMap.setView([lat, lon], 16);
            }

            navigator.geolocation.watchPosition(
                async function (position) {
                    if (isCodeInteractionPaused) {
                        // console.log("Code update paused due to user interaction."); // Optional for debugging
                        return; // Skip OLC display updates
                    }

                    length = 4;
                    if (dot == "") {
                        dot = ".";
                    } else {
                        dot = "";
                    }

                    let coords = position.coords;
                    acc = coords.accuracy;

                    if (acc < 15) {
                        length = 11;
                    } else if (acc < 300) {
                        length = 10;
                    } else if (acc < 6000) {
                        length = 8;
                    } else if (acc < 120000) {
                        length = 6;
                    }

                    currentOlc = OpenLocationCode.encode(
                        coords.latitude,
                        coords.longitude,
                        length,
                    );

                    // Cache the current location for manual refresh
                    lastKnownLocation = coords;

                    document.getElementById("code").title = currentOlc; // Update title for buttons
                    document.getElementById("region").innerHTML =
                        currentOlc.substring(0, 4);
                    document.getElementById("local").innerHTML =
                        currentOlc.substring(4);
                    document.getElementById("accuracy").innerHTML =
                        "Accuracy: within " +
                        Math.floor(acc) +
                        " meters " +
                        dot;

                    let navInputValue = document
                        .getElementById("navinput")
                        .value.trim();
                    let navInputUpper = navInputValue.toUpperCase();

                    document.getElementById("map").href =
                        "https://plus.codes/map/" +
                        (navInputUpper || currentOlc);
                    document.getElementById("refhref").href =
                        "https://nominatim.openstreetmap.org/reverse.php?format=html&lat=" +
                        coords.latitude +
                        "&lon=" +
                        coords.longitude +
                        "&zoom=18";

                    try {
                        if (navInputValue) {
                            // Use async resolve with geocoding fallback
                            document.getElementById("nav2").innerHTML =
                                "Resolving...";
                            let destination = await resolveWithGeocoding(
                                navInputUpper,
                                coords.latitude,
                                coords.longitude,
                            );
                            if (destination) {
                                // Update last known good destination
                                lastKnownGoodDestination = destination;
                                lastKnownGoodInput = navInputValue;
                                clearFailedLookup(navInputValue);

                                let destinationOlc = OpenLocationCode.encode(
                                    destination.latitudeCenter,
                                    destination.longitudeCenter,
                                    Math.max(6, destination.codeLength),
                                );
                                document.getElementById("navapp").href =
                                    "https://www.google.com/maps/dir/?api=1&destination=" +
                                    encodeURIComponent(navInputValue);

                                let distance = dist(
                                    coords.latitude,
                                    coords.longitude,
                                    destination.latitudeCenter,
                                    destination.longitudeCenter,
                                );
                                let direction = dirfunc(
                                    coords.latitude,
                                    coords.longitude,
                                    destination.latitudeCenter,
                                    destination.longitudeCenter,
                                );
                                document.getElementById("nav2").innerHTML =
                                    `Target is ~${distance}m away (${direction})`;

                                // Update compass and mini map
                                updateCompass(
                                    coords.latitude,
                                    coords.longitude,
                                    destination.latitudeCenter,
                                    destination.longitudeCenter,
                                );
                                updateMiniMap(
                                    coords.latitude,
                                    coords.longitude,
                                    destination.latitudeCenter,
                                    destination.longitudeCenter,
                                );

                                if (
                                    location.hash.substring(1) !== navInputValue
                                ) {
                                    location.hash = navInputValue;
                                }
                                localStorage.setItem(
                                    location.pathname,
                                    navInputValue,
                                );
                                messages(
                                    "geo" + destinationOlc.substring(0, 6),
                                    document.getElementById("messages"),
                                    currentOlc.startsWith(
                                        destinationOlc.substring(0, 6),
                                    ),
                                );
                            } else {
                                document.getElementById("nav2").innerHTML =
                                    "(Location not found - invalid OLC or unknown place)";
                                // Hide compass when destination not found
                                document.getElementById(
                                    "direction-compass",
                                ).style.display = "none";
                                // Show current location only when destination not found
                                showCurrentLocationOnMap(
                                    coords.latitude,
                                    coords.longitude,
                                );
                                recordFailedLookup(navInputValue);
                                messages(
                                    "geo" + currentOlc.substring(0, 6),
                                    document.getElementById("messages"),
                                    true,
                                );
                            }
                        } else {
                            document.getElementById("nav2").innerHTML =
                                nav2default;
                            // Hide compass when no destination but show current location
                            document.getElementById(
                                "direction-compass",
                            ).style.display = "none";
                            showCurrentLocationOnMap(
                                coords.latitude,
                                coords.longitude,
                            );
                            document.getElementById("navapp").href =
                                "https://www.google.com/maps/@?api=1&map_action=map&center=" +
                                coords.latitude +
                                "," +
                                coords.longitude;
                            messages(
                                "geo" + currentOlc.substring(0, 6),
                                document.getElementById("messages"),
                                true,
                            );
                        }
                    } catch (e) {
                        console.error(
                            "Error processing navigation/destination:",
                            e,
                        );
                        document.getElementById("nav2").innerHTML = nav2default;
                        // Show current location even when there's an error
                        showCurrentLocationOnMap(
                            coords.latitude,
                            coords.longitude,
                        );
                        messages(
                            "geo" + currentOlc.substring(0, 6),
                            document.getElementById("messages"),
                            true,
                        );
                    }
                },
                function (err) {
                    console.warn(
                        "GEOLOCATION ERROR(" + err.code + "): " + err.message,
                    );
                    document.getElementById("accuracy").innerHTML =
                        "Could not get location. Use manual entry below.";

                    // Manual location option is always visible now, just highlight it
                    const manualBtn = document.getElementById(
                        "enable-manual-location",
                    );
                    manualBtn.style.background = "#ffc107";
                    manualBtn.style.color = "#212529";
                    manualBtn.textContent =
                        "⚠️ GPS failed - Enter location manually";

                    let fallbackOlc = location.hash.substring(1) || "8FXC0000+";
                    if (
                        typeof OpenLocationCode !== "undefined" &&
                        OpenLocationCode.isValid(fallbackOlc.toUpperCase())
                    ) {
                        messages(
                            "geo" + fallbackOlc.substring(0, 6).toUpperCase(),
                            document.getElementById("messages"),
                            false,
                        );
                    }
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 5000,
                },
            );

            const codeDisplayElement = document.getElementById("code");
            const copyCodeButton = document.getElementById("copyCodeButton");
            const shareCodeButton = document.getElementById("shareCodeButton");

            function getCurrentValidOlcFromTitle() {
                const olc = codeDisplayElement.title;
                if (
                    typeof OpenLocationCode !== "undefined" &&
                    OpenLocationCode.isValid(olc.toUpperCase())
                ) {
                    return olc;
                } else {
                    alert(
                        "Location code not yet available or is invalid. Please wait for GPS to provide a valid code.",
                    );
                    return null;
                }
            }

            if (copyCodeButton) {
                copyCodeButton.addEventListener("click", async function () {
                    const codeToCopy = getCurrentValidOlcFromTitle();
                    if (!codeToCopy) return;

                    isCodeInteractionPaused = true;
                    await new Promise((resolve) => setTimeout(resolve, 50)); // Brief pause

                    try {
                        if (
                            navigator.clipboard &&
                            navigator.clipboard.writeText
                        ) {
                            await navigator.clipboard.writeText(codeToCopy);
                            alert(
                                "Code '" +
                                    codeToCopy +
                                    "' copied to clipboard!",
                            );
                        } else {
                            const textArea = document.createElement("textarea");
                            textArea.value = codeToCopy;
                            textArea.style.position = "fixed";
                            textArea.style.opacity = "0";
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            try {
                                document.execCommand("copy");
                                alert(
                                    "Code '" +
                                        codeToCopy +
                                        "' copied to clipboard (fallback)!",
                                );
                            } catch (err) {
                                console.error("Fallback copy failed: ", err);
                                alert(
                                    "Automatic copy failed. Your code is: " +
                                        codeToCopy +
                                        "\nPlease copy it manually.",
                                );
                            }
                            document.body.removeChild(textArea);
                        }
                    } catch (err) {
                        console.error("Failed to copy: ", err);
                        alert(
                            "Could not copy code. Your code is: " +
                                codeToCopy +
                                "\nPlease copy it manually. Error: " +
                                err.message,
                        );
                    } finally {
                        setTimeout(() => {
                            isCodeInteractionPaused = false;
                        }, 100);
                    }
                });
            }

            if (shareCodeButton) {
                shareCodeButton.addEventListener("click", function () {
                    const codeToShare = getCurrentValidOlcFromTitle();
                    if (!codeToShare) return;

                    isCodeInteractionPaused = true;
                    new Promise((resolve) => setTimeout(resolve, 50)).then(
                        () => {
                            // Brief pause
                            var webShare = "share" in navigator;
                            if (webShare) {
                                navigator
                                    .share({
                                        title: "My WhenWhere.uk Location",
                                        text:
                                            "My current location code is: " +
                                            codeToShare +
                                            ". Join me or see where I am!",
                                        url:
                                            location.href.match(/^[^#]*/)[0] +
                                            "#" +
                                            codeToShare,
                                    })
                                    .then(() => {
                                        console.log("Shared successfully");
                                    })
                                    .catch((error) => {
                                        if (error.name !== "AbortError") {
                                            console.error(
                                                "Error sharing:",
                                                error,
                                            );
                                        } else {
                                            console.log(
                                                "Share aborted by user.",
                                            );
                                        }
                                    })
                                    .finally(() => {
                                        setTimeout(() => {
                                            isCodeInteractionPaused = false;
                                        }, 100);
                                    });
                            } else {
                                const fullUrl =
                                    location.href.match(/^[^#]*/)[0] +
                                    "#" +
                                    codeToShare;
                                alert(
                                    "Web Share not supported. Your code is: " +
                                        codeToShare +
                                        "\nURL to share: " +
                                        fullUrl +
                                        "\n\nPlease use the copy button or copy this information manually.",
                                );
                                setTimeout(() => {
                                    isCodeInteractionPaused = false;
                                }, 100);
                            }
                        },
                    );
                });
            }
        </script>
        <script>
            // register serviceworker

            if ("serviceWorker" in navigator) {
                navigator.serviceWorker
                    .register("service-worker.js")
                    .then(function () {
                        console.log("Service Worker Registered");
                    })
                    .catch(function (err) {
                        console.error(
                            "Service Worker registration failed: ",
                            err,
                        );
                    });
            }
        </script>
    </body>
</html>
